const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\nconst cors = require('cors');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\napp.use(cors());\napp.use(express.static('public'));\n\nconst dbPath = path.join(__dirname, 'trades.db');\nconst db = new sqlite3.Database(dbPath);\n\n db.serialize(() => {\n  db.run(`CREATE TABLE IF NOT EXISTS trades (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n    symbol TEXT DEFAULT 'BTCUSDT',\n    rsi REAL,\n    signal TEXT,\n    entry_price REAL,\n    exit_price REAL,\n    pnl REAL,\n    is_win INTEGER DEFAULT 0\n  )`);\n});\n\n// Generate sim trades if empty\ndb.get("SELECT COUNT(*) as cnt FROM trades", (err, row) => {\n  if (row && row.cnt === 0) {\n    generateSimTrades();\n  }\n});\n\nfunction generateSimTrades() {\n  const count = 30;\n  for(let i = 0; i < count; i++) {\n    const rsi = Math.random() < 0.5 ? (25 + Math.random() * 10) : (70 + Math.random() * 10);\n    const signal = rsi < 35 ? 'BUY' : 'SELL';\n    const entry_price = 45000 + Math.random() * 10000;\n    const change_pct = (Math.random() - 0.4) * 0.06; // bias to positive\n    const exit_price = entry_price * (1 + change_pct);\n    const pnl = signal === 'BUY' ? (exit_price - entry_price) : (entry_price - exit_price);\n    const is_win = pnl > 0 ? 1 : 0;\n    db.run(`INSERT INTO trades (rsi, signal, entry_price, exit_price, pnl, is_win) VALUES (?, ?, ?, ?, ?, ?)`,\n      [rsi.toFixed(2), signal, entry_price, exit_price, parseFloat(pnl.toFixed(4)), is_win],\n      (err) => { if (err) console.log(err); }\n    );\n  }\n  console.log(`Generated ${count} simulated trades.`);\n}\n\n// API endpoints\napp.get('/api/stats', (req, res) => {\n  db.get(`\n    SELECT \n      COUNT(*) as total_trades,\n      COALESCE(SUM(pnl), 0) as total_pnl,\n      COALESCE(AVG(is_win)*100, 0) as winrate,\n      COALESCE(SUM(CASE WHEN pnl < 0 THEN pnl ELSE 0 END), 0) as total_losses,\n      COUNT(CASE WHEN pnl < 0 THEN 1 END) as num_losses\n    FROM trades\n  `, (err, stats) => {\n    if (err) {\n      res.status(500).json({error: err.message});\n    } else {\n      res.json(stats);\n    }\n  });\n});\n\napp.get('/api/trades', (req, res) => {\n  db.all('SELECT * FROM trades ORDER BY id DESC LIMIT 10', (err, rows) => {\n    res.json(rows || []);\n  });\n});\n\napp.get('/api/monitor', (req, res) => {\n  db.get('SELECT * FROM trades ORDER BY id DESC LIMIT 1', (err, row) => {\n    res.json({\n      current_rsi: row ? parseFloat(row.rsi).toFixed(2) : 50,\n      current_price: row ? parseFloat(((parseFloat(row.entry_price) + parseFloat(row.exit_price))/2).toFixed(2)) : 50000,\n      signal: row ? row.signal : 'HOLD',\n      status: 'Running'\n    });\n  });\n});\n\napp.get('/api/sparkline', (req, res) => {\n  db.all(`\n    SELECT \n      id,\n      COALESCE(SUM(pnl) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 0) as equity\n    FROM trades \n    ORDER BY id ASC\n  `, (err, rows) => {\n    if (err) {\n      res.status(500).json({error: err.message});\n    } else {\n      const recent = rows.slice(-20);\n      res.json({\n        labels: recent.map(r => `#${r.id}`),\n        data: recent.map(r => parseFloat(r.equity.toFixed(2)))\n      });\n    }\n  });\n});\n\napp.get('/api/health', (req, res) => {\n  res.json({status: 'healthy', uptime: process.uptime(), last_update: new Date().toISOString()});\n});\n\napp.get('/api/trend', (req, res) => {\n  db.all('SELECT pnl FROM trades ORDER BY id DESC LIMIT 5', (err, rows) => {\n    if (rows.length === 0) {\n      res.json({trend: 'Neutral', change: '0%'});\n    } else {\n      const avg = rows.reduce((sum, r) => sum + parseFloat(r.pnl), 0) / rows.length;\n      const trend = avg > 0 ? 'Bullish' : 'Bearish';\n      const change = (avg * 5).toFixed(2) + '%'; // approximate\n      res.json({trend, change});\n    }\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(`RSI Dashboard running on port ${PORT}`);\n});